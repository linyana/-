# 2022.10.28

# JavaScript -- ES6

## let , const ,var 

> 通常我们会使用let定义会重复赋值的变量，用const定义常量或者引用地址不会发生改变的变量。

> 需要注意的是let和const不会像var一样存在变量提升的问题，例如var a = 0，那么在作用域的顶部就会默认存在一次声明 : var a ; let和const不会，但这也会导致一个情况的发生 : 在声明这这句话之前不能像var一样读到undefined，而是ReferenceError ， 这就是暂时性死区问题，在let的声明之前无法读取这个值，这也意味着typeof不是一个百分百安全的操作，因为在这种情况下会报错 : ReferenceError。

## let , const , var的一些区别

+ cosnt在声明时必须进行赋值，var和let不用。
+ let 和 const都不能在同一作用域重复声明同一个变量 => 这也意味着不能在函数内部声明参数。
+ let 和 const 存在块级作用域，var没有。
+ var存在变量提升，let 和 const 没有。
+ let 和 const 存在暂时性死区，var没有。

## 变量的解构赋值

### 官方解释 :

> ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。

### 常见例子 : 

```
let [a, b, c] = [1, 2, 3];
// a = 1 , b = 2 , c = 3
```

> 除此之外比较常用的还有

```
// 给变量赋初值
let [x = -1 , y = x] = [];
// x = 1	y = -1

// 覆盖这个初始值
let [x = -1 , y = x] = [1, 1]
// x = 1 y = 1; 

// 注意参数的顺序
let [x = y, y = 1] = []
// 报错，不能在初始化y之前访问y(暂时性死区)
```

> 对于对象来说，解构赋值是一种非常方便的赋值方式，例如

```
// 注意对象中是没有顺序的
let { x, y } = {y: 1,x:2}
// x = 2 y = 1
// 这一点在实际开发中是非常方便的,比如我们在接收JSON后给变量赋值用这样的方法就非常快捷。
```

> 解构也可以用于对象嵌套

```
// 参考于ES6-阮一峰
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p: [x, { y }] } = obj;
x // "Hello"
y // "World"
```

### 需要注意的点
+ 在解构赋值中赋值失败的变量会返回undefined。
+ 在解构赋值中，如果等号右边不可迭代，那么会报错。
+ 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。

## 模板字符串
```
	`hello ${world}`
```

> 其中，模板字符串还可以进行嵌套

```
	`
	${
		<div>
			hello ${world}
		</div>
	}
	`
```

> 如果想调用模板字符串，就需要把他写成函数的return值，如

```
	cosnt fun = (name) => {
		return `hello ${name}`
	}
```

> 这样就可以将模板字符串进行调用了。

